
static - 1989-95

96 to till dynamic content generation technologies

  -cgi - c,perl
  -java -servlet,jsp
  -asp
  -php
  -node
  ....
out put - html

1999 - ECOMMERCE---Web Services

  Web app--output is not html page ----|Data--Data Interchange formate---|xml
   WEBSERVICE-XML BASED webservice -SOAP

2005 -mobile computing

  Web app--output is not html page ----|Data--Data Interchange formate---|JSON
   WEBSERVICE-Data independent---|RESTFull---data|xml,json,pdf.....

  template engine + biz logic +data===

2008-SINGLE WEb app- spa =>w3c ===>HTML 5,CSS3,javascript new browser api===>SPA

  -angular js--first professional spa framework ----> template engine + models +controller=>
   mvc


 SPA--JSON----HTTP<------RESTFull WebService

ES 6 Features:

javascript language version no ES 6:
ECMA SCRIPT:  
ES 1-97,ES 3-99,ES 4-2006, ES 5-2007,ES6-2012-2015....ES 7, ES8,ES 9

js is object based,functional style,event driven pl.

Language fundamentals
functional programming
object based programming
networking-ajax
UI- DOM

Node js 

//Language fundamentals
/**
 * js is dynamic typed language : no type is required to declare variables.
 * types are identified during runtime only.
 * types :
 *  -string - 16 bit unicode character
 *  -number - size 64 bit - double
 *  -boolean - size 1 bit
 *  -undefined
 *  -function
 *  -object
 * values : iterals 
 *  based on literal only type is identified
 *  -string
 *  -number
 *  -boolean
 *  -undefined
 *  -NaN - number : Not a Number : runtime numerical errors
 *  -infinity : number : div/0
 *  -function
 *  -null - object
 *  -object
 * variable declaration 
 *   -var  - old way - es5 style
 *   -let  -es 6
 *   -const - es 6
 *            -----local variables
 *   -this - old way  - instance variables
 * 
 *   
 * 
 */

//Language fundamentals
//advanced booleans.
/**
 * in java script everything is true execept the following values
 * //falsy values
 * 1.boolean false
 * 2.0
 * 3."",'' empty string
 * 4.NaN 
 * 5.null
 * 6.undefined
 *
 * control statements && loops
 *  -if
 *  -switch..
 *  - for,while,do..while
 * operators : 
 *   1. ==,=== !=,!==
 *   2. ||  , &&
 *   3. typeof, new,instanceof....
 *   4.tenary operator :?
 * 
 */

let isActive = true;
if (isActive) {
    console.log('Active')
} else {
    console.log('Not active')
}
//using tenary
isActive ? console.log('Active') : console.log('Not active');

let start = 0;
if (start) {
    console.log('start')
} else {
    console.log('Not start')
}

//equal
// == , ===
//== compares only value not type; it is bug
// === compares type + value : it is recommended
let x = "10";
let y = 10;
x == y ? console.log('EQUAL') : console.log('NOT EQUAL');
x === y ? console.log('EQUAL') : console.log('NOT EQUAL');

// ||

let isCold = true;
let haveHeat = true;

isCold || haveHeat ? console.log('infected by COVID-19') : console.log('You are fine')

/**
 * if first operand(counter)  is truthy, the result would be first operand else 
 * second operand 
 */

let counter = 10;
let totalCounter = counter || 1;
console.log(`Total Counter ${totalCounter}`);


//const keyword
/**
 * let means , you can reintialize
 * const , once declared cant be reinitalized 
 */
let a = 10;
console.log(`a ${a}`)
a = 90;
console.log(`a ${a}`)

const x =10;
console.log(`x ${x}`)
//x =100

/**
 * Functional programming
 *  -how to declare functions 
 *     -definition pattern
 *     -literal pattern
 *     -anonmous functions
 *  -es 5 functions
 * -es 6 functions - arrow functions
 *  
 * -function declartion properties
 *    - params and args
 *    -return values
 * Note ; function can take any litreal as parameter and return any thing
 *     -take any value including function.
 */

//definition pattern : function declaration
function sayHello() {
    console.log("hello")
}
//function call
sayHello();
//paramaters and args
//a,b are args
//default args : es 6 feature
function add(a = 1, b = 1) {
    let c = a + b;
    console.log(`Add Result  ${c}`)
}
//10,10 are parameters
add(10, 10)
//undefined , undefined
add();
//return values
function substract(a = 1, b = 1) {
    let c = a - b;
    return c;
}
console.log(`Result Substract ${substract(10, 2)}`)
console.log(`Result Substract ${substract()}`);
//*************************************************************************************
//syntax 2 : literal pattern
/**
 * let a =10;
 *  10 literal number
 * function is literal(value),
 *  1. can be assigned to a variable
 *  2. can be passed as parameter to another function
 *  3. can be returned from another function
 *  
 * once a function assinged,passed, returned , can invoked like normal function. 
 * 
 * types:
 *   1.named function
 *   2.anonmous function /nameless function
 * 
  */

// *  1. can be assigned to a variable
//  *   1.named function

let greeter = function sayGreeter() {
    console.log('Say Greeter');
};
//call a function using a variable
greeter();
//2.anonmous function /nameless function
let hai = function () {
    console.log('Say Hai');
};
hai();
//parameters and args , returns
let multiply = function (a = 1, b = 1) {
    return a * b;
};
console.log(multiply(10, 2));
//////////////////////////////////////////////////////////////////////////////////
//how to pass function as parameter

//start is just variable
/**
 * 
 * @param {*} start 
 * start= function () {
    //function body
    console.log('Starting......')
}
 */
function connect(start) {
    //call the function
    let status = start('HttpServer');
    status ? console.log('Server is Ready to Accept Requests') : console.log('Server is Failed!')
}
//passing anonmous function
connect(function (param) {
    //function body
    console.log(`${param} Starting......`)
    return true;
});

//
let connector = function (start) {
    //call the function
    let status = start('TCP Server');
    status ? console.log('Server is Ready to Accept Requests') : console.log('Server is Failed!')
};
connector(function (param) {
    //function body
    console.log(`${param} Starting......`)
    return true;
});
/////////////////////////////////////////////////////////////////////////////////
//Returnning function from another

// function counter() {
//     function inc() {
//         console.log('inc')
//     }
//     //
//     inc();
// }
// function counter() {
//     return function inc() {
//         console.log('inc')
//     };
// }
function counter() {
    return function () {
         console.log('inc');
    };
}
let increment = counter();
increment();
//short cut
counter()();




//es 6 function literal ; arrow function

/**
 * why arrow
 *  1.syntax simple
 */
//old way
let hai = function () {
    console.log('Hai');
};
hai();
let hi = () => {
    console.log('Hai');
};
hi();
//flavours of arrows
//1. if function has single line of body, remove {}
let newHai = () => console.log('Hai');
newHai();

//2.with args and parameters : multi parameters with default args
let add = (a = 1, b = 2) => {
    let result = a + b;
    console.log(`Result is ${result}`);
}
add(10, 10);
//2.with args and parameters : single parameters without  default args :drop ()
let stock = value => console.log(`Value ${value}`);
stock(100);

//3 return values : with body
let substract = (a = 1, b = 2) => {
    let result = a - b;
    return `Result is ${result}`;
};
console.log(`Result is ${substract(12, 89)}`);

//4.only return , no body , drop {} and return statement
let getValue = () => 10;
console.log(getValue())
//get value ,no default args, return the same 
let setAndGetValue = value => value;
console.log(setAndGetValue(100));
//************************
//function as parameter
let connect = start => start('HTTP SERVER');
connect(param => console.log(`${param} is starting....`));

//return function as parameter
let counter = () => () => console.log('inc')
counter()()
**********************************************************************************************



//How to create object?
/**
 * 1.constructor pattern
 *    es 5 functions as class
 *    es 6 classes
 * 2.literal pattern
 *   
 */

function Employee(id = 1, name = 'default') {
    //state, behaviour
    this.id = id; //1;
    this.name = name;//'Subramanian';
    //mehtods
    this.calculate = function () {
        return 1000;
    }

}
//emp is reference variable , new is keyword to create  object , 
//Employee() constructor call.
let emp = new Employee(12, 'Subramanian');
//emp.id = 9000;
console.log(`${emp.id} ${emp.name} ${emp.calculate()}`)


class Customer {
    //state, behaviour
    id = 1;
    name = 'Subramanian';
    constructor(id = 1, name = 'Subramanian') {
        this.id = id;
        this.name = name;
    }
    //mehtods
    // calculate = function () {
    //     return 1000;
    // }
    calculate() {
        return 1000;
    }

}
let cust = new Customer(23, 'Ram');
cust.id = 8888;
console.log(`${cust.id} ${cust.name} ${cust.calculate()}`)

//literal pattern : no class,function

let order = {
    id: 1,
    name: 'Computers',
    qty: 100,
    price: 100,
    inStock: true,
    calculate: function () {
        return this.qty * this.price
    },
    //arrow
    calculateCost: () => {
        //kindly refer this keyword inside arrow : this keyword inside is different 
        //meaning
        return order.qty * order.price
    },
    // es 6 class pattern
    calculateNewCost() {
        return this.qty * this.qty;
    }

}
console.log(order.calculate(), order.calculateCost(), order.calculateNewCost())




//object destructuring:

//without destructring
function display(employee) {
    //log all details
    console.log(`Id ${employee.id}`)
    console.log(`Name ${employee.name}`)
    console.log(`City ${employee.city}`)
    console.log(`State ${employee.state}`)
}
function display1(employee) {
    //extract object properties
    const { id, name, city, state } = employee;
    //log all details
    console.log(`Id ${id}`)
    console.log(`Name ${name}`)
    console.log(`City ${city}`)
    console.log(`State ${state}`)

}

//extract object properties
function display2({ id, name, city, state }) {
    //log all details
    console.log(`Id ${id}`)
    console.log(`Name ${name}`)
    console.log(`City ${city}`)
    console.log(`State ${state}`)

}
const displayArrow = ({ id, name, city, state }) => {
    //log all details
    console.log(`Id ${id}`)
    console.log(`Name ${name}`)
    console.log(`City ${city}`)
    console.log(`State ${state}`)

};

display({ id: 1, name: 'Subramanian', city: 'Coimbatore', state: 'Tamil Nadu' });
display1({ id: 1, name: 'Subramanian', city: 'Coimbatore', state: 'Tamil Nadu' });
display2({ id: 1, name: 'Subramanian', city: 'Coimbatore', state: 'Tamil Nadu' });
displayArrow({ id: 1, name: 'Subramanian', city: 'Coimbatore', state: 'Tamil Nadu' });

// //
// function getStock(id = 1, symbol = 'google', price = 100) {
//     // return {
//     //     id: id,
//     //     symbol: symbol,
//     //     price: price
//     // };
//     //key:value ===same => remove one
//     return {
//         id,
//         symbol,
//         price
//     };
// }
// //
// const getStock=(id = 1, symbol = 'google', price = 100) => {
//     return {
//         id,
//         symbol,
//         price
//     };
// };

const getStock = (id = 1, symbol = 'google', price = 100) => ({
    id,
    symbol,
    price
});

console.log(getStock())


*********************************************************************************************

Node.js:

What is Node?
  
 Node is javascript runtime and platform to run javascript programs standalone manner.

javascript is language , its runtime embeded inside every browser.

2008,Ryan Dhal, who invented a model how to run javascript outside browser : Node.js

Google , when they started chrome project, google announched javascript will be open source.
Chrom js runtime called "v8".

What is V8?
V8 is Google’s open source high-performance JavaScript and WebAssembly engine, written in C++. It is used in Chrome and in Node.js, among others.

Node js created out of V8.

V8 was released for chrome browser for high performance javascript at browsers.

Node js was born to build "network applications by using "

 -non blocking / async programming : async io

Why Node.js

 - to build high performance network applications using min resources

*****************************************************************************************

Architure of Node.js:
....................

Blocking and sync programming:
..............................

Concurrency:
     -doing many things at same : parrel programming : 
           -multi process ,mutltithreading

Types of threading:

 -Process level concurrency.
        Creating and running, managing threads at process level : legacy model

 -Worker thread model concurrency.


-Process level concurrency. : Blocking and sync.
////////////////////////////////////////////////
        Creating and running, managing threads at process level : legacy model

Use case java:web stack

tomcat  =  http + jvm

Client             Tomcat
req1------------create/allocate new thread----do insentive io operation-->1 gb file
req2-----------create/allocate new thread ----read database records
req3-----------create/allocate new thread---simple html

Drawbacks:

1.more threads, performance issue
2.it leads , thread issues like race condition,deadlock.....

Solution:
  isloate thread creation,running,managing outside 

Worker thread model concurrency.


--based on design pattern : Reactor Pattern
*********************************************************************************************

Node is just js runtime, like browser runtime.

Application of node:

async/nonblocking
1.buliding web apps
2.building high file io applications
3.socket programming
.......
**********************************************************************************************

node runtime has two mode

1.REPL model - Read Evaluate Print loop.
  to run js code with out writing. for interactive command line tool.

2.node command 

   node jscode.js

Objects in node:

in browser :
 window,document,history,location --dom objects ; not available in node.

in browser window is super object, in node process is the super object
*****************************************************************************************

Node Progrm stack:

1.node application modularity
2.node api
3.node - io apis
  -web, app,fs
4.node package manager -npm.
*******************************************************************************************

js modularity :

modularity : breaking application , sharing code across the files.

java : packages, import 

by default js provides file based modularity, file linking. 

even today js is very weak in modualrity.

In 2000 js community, started working on modualrity js.

proposed lot of design patterns: modular design patterns.

1.javascript namespace design pattern : - 1st - jquery 
2.amd -asyn module defintion
3.cjs - common js - even today this design pattern is avilable
   note; node.js was designed with commonjs by default.
4.es 6 modules- es6
5.system 
6.UMD -unversial module definition

cjs,es6
.......

commonjs implementation:

1.node popularized this design pattern
2.node uses this design pattern by default.


Common objective of theses design patterns

1.how to link files
2.how to share code among files.

cjs and node

1.how to link files
   require()
    it is function, used to link files
  require functions retuns code either in the form object or other.

2.sharing code 
   exports
   module.exports



use case 1: just link files

mylib.js


console.log('mylib');

index.js
require('./mylib')


use case 1: just link files and share code

code:
 could be any thing we declare
 variable having - string,number,boolean,object,function.....
 function
 class
 object
 array
.......

exports

exports.id = 1;

 what  is exports
 what is id 
 what is 1

exports is just variable and its value is literal object by default.

if you want understand exports, you have to understand js concept called "Object Augmenation"

//Object augmentation:
//object memory layout
/**
 * object is memory having key : value pair structure : hash table/ dictionary
 *  yes every object in js is simple dictionary/map
 * note: since object is map, you can perform curd operation on object.
 *  -add,delete,update,iterate,search
 *      - Object augmentation
 */


let emp = {
    id: 1
};
 //here only 1 property has been declared
console.log(emp.id)
//add operations
emp.firstName = 'Subramanian' //setter
console.log(emp.firstName) //getter

//update : if prop exits, then update, else add
emp.firstName = 'John'
console.log(emp.firstName) //getter

emp.salary =9000;
console.log(emp.salary) //getter

//delete
delete emp.salary;
console.log(emp.salary) //getter

//iteration
for (const key in emp) {
  console.log(key,emp[key])
}


************************************


syntax  for require function

 function require(fileName){
   let exports={};


   return exports ;          

 }

let result= require('./mylib')



mylib.js


//sharing code via exports
/**
 * 
 function require(fileName){
   let exports={};
   //augmentation
   exports.firstName ='Subramanian'
   exports.firstName = 'Subramanian'
  exports.lastName = 'Murugan';
  exports.id = 1;
  exports.isActive = true;
exports.checkStatus = function () {
    return 'Available'
}
exports.address = {
    city: 'Coimbatore'
}
exports.skills = ['java', 'javascript'];
   return exports ;          

 }

let result= require('./mylib')
 */

exports.firstName = 'Subramanian'
exports.lastName = 'Murugan';
exports.id = 1;
exports.isActive = true;
exports.checkStatus = function () {
    return 'Available'
}
exports.address = {
    city: 'Coimbatore'
}
exports.skills = ['java', 'javascript'];

index.js
//let result = require('./mylib');

const { firstName, lastName, id, isActive,checkStatus } = require('./mylib');
//console.log(result.firstName,result.lastName);

console.log(`${id} ${firstName} ${lastName}  ${isActive} `);
console.log(`${checkStatus()}`)

******************************************************************************************
module.exports:
   -module.exports does not return object.
   -it exports the code as it is- if you return variable it returns variable
   -require function wont get as object.
   -you cant have more than one module.exports in a single file.





let name = require('./lib/name');
let adder = require('./lib/add');

console.log(name);
console.log(adder(12,90));

src/lib/add.js


function add(a = 1, b = 2) {
    return a + b;
}

module.exports = add;


//declare single name

const name = 'Subramanian';

//export it
module.exports = name;

let name = require('./lib/name');
let adder = require('./lib/add');

console.log(name);
console.log(adder(12,90));






class TodoRepository{
    constructor(){
        console.log('TODO Repository')
    }
    //method
    findAll(){
        return 'Todo repository-Repository'
    }
}
module.exports = TodoRepository;

const TodoRepository = require('../respository/TodoRepository');

class TodoService {
    todoRepository = null;
    constructor() {
        console.log('TodoService')
        this.todoRepository = new TodoRepository();
    }
    findAll() {
        return this.todoRepository.findAll();
    }
}
module.exports = TodoService;

const TodoService = require('../services/TodoService');

class TodoController {
    todoService = null;
    constructor() {
        console.log('TodoController')
        this.todoService = new TodoService();
    }
    findAll() {
        return this.todoService.findAll();
    }
}
module.exports = TodoController;


const TodoController = require('./controller/TodoController');


function start(){

    const todoCtrl= new TodoController();
    console.log(todoCtrl.findAll())

}
start();
*********************************************************************************************
Node js:

-nonblocking and async:

async programming:

1.node(js) provides a high level async apis

common java script apis(browsers):
..................................
1.timers
   settimeout,setinterval
2.ajax api -only in browser
   xhr.
3.websocket api - in browser and in node.
4.all dom events api -only browser

Node apis:
 node offers 90% api non blocking - io,networking,web.....
http,fs,tcp.......


2.you need to pass functions as parameter to async api
   -handler function /callback function : to handle completed async result

timers   

1.timers
   settimeout,setinterval



Style/patterns of async programming
...................................

1.callback pattern
2.promise pattern
3.async...await patterns


/**
 * Async programming :
 *  timer api
 *    -setTimeout
 *       -if you want to schedule any task in delayed manner using cpu timer.
 *        once timeout is completed, handler function will be ready to handle result
 */

function delay(handler) {
    let fakeData = "Hello!How areyou"
    //timer logic
    setTimeout(handler, 5000, fakeData);
}

console.log('start')
delay(function (data) {
    console.log(`${data}`)
});
console.log('stop');

//arrow version

const { log } = console;
const sleep = callback => {
    let fakeData = 'Awaken!!'
    setTimeout(callback, 6000, fakeData);
};
sleep(data => console.log(data));
//with object destrucing
sleep(log);

**********************************************************************************************

const TodoService = require('./api/TodoService');


//Access todo app
let todoService = new TodoService();
//sync call
function syncCall() {
    console.log('start todo')
    console.log(todoService.findAllSync());
    console.log('end todo')
}
//syncCall()

function asyncCall() {
    console.log('start todo')
    
    todoService.findAllAsync(todos => {
        console.log(todos);
    });
    console.log('end todo')

}
asyncCall();

const TODOS = require('../data/todos')

class TodoService {
    constructor() {

    }
    findAllSync() {
        return JSON.stringify(TODOS);
    }
    //i want to return todos async
    findAllAsync(handler) {
        //todos data will be returned after 5sec
        setTimeout(handler, 5000, TODOS)
    }


}
module.exports = TodoService;

**************************************************************************************

Callback nesting: // nested callbacks:
 .....................................

  The out put of one callback, will be input to another callback.


if you request something, the out put would be either data or error.

//callback nesting

/**
 * how to pass two callbacks, 
 *  -one is going to handle - success -resolve
 *  -another one is going to handler - failure-reject
 */
const { log } = console;

const getUser = (resolve, reject) => {
    //biz logic to simulate success and failure
    let user = {
        id: 1,
        name: 'admin'
    };
    let err = {
        code: 500,
        message: 'User not Found!!'
    }

    if (user) {
        setTimeout(resolve, 1000, user);
    } else {
        setTimeout(reject, 1000, err);
    }

};

//login method takes 3 args -  user,resolve,reject

const login = (user, resolve, reject) => {
    //biz logic
    const SUCCESS = 'Login success';
    const FAILURE = 'Login Failed';
    if (user.name === 'admin') {
        setTimeout(resolve, 1000, SUCCESS)
    } else {
        setTimeout(reject, 1000, FAILURE);
    }

};


// getUser(user => {
//     //nesting 
//     log('User is called')
//     login(user, success => {
//         log(success);
//     }, failure => {
//         log(failure);
//     });
// }, err => {
//     log(err);
// });
getUser(user => {
    //nesting 
    log('User is called')
    login(user, log, log);
}, log);

callback hell:
..............

look at the above function call, ask your self

Questions:

1.Whether this code is able to understand quickly
2.Whether this code is able to debug
3.Whehter this code is scalable?
4.whether this code is maintaiable?

  "No" : This is what we call as "Callback hell"

Callback hell is not error, but way of writing async programming using nested callback.


fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})

How to write better callback programming? or How to avoid callback hell?

Solution : One Design pattern is 


In 2005, JQUERY team started with working complex callback patterns, they found callback
hell problem.

They proposed a  Design pattern to write better callback programming(Async) programming.

  "promise".


Promise is design pattern which hides complexity of callback patterns.

SInce Promise is design pattern, many people have implemented Promise design pattern.

1.JQuery -first promise implementation
2.many libs and frameworks

Because of popularty of this design among javascript developers, ECMA 6 Committee introduced
"promise design pattern in ES6 as Promise Object"

Promise Object is reference implementation of "promise design pattern".


Js has lot of built in objects

Object
Wrapper Objects: Number,String,Boolean
Math
Date
JSON --Parser Object
Promise

features of Promise Object:
.............................

1.Promise by deafult is Async. Which implements timer api with 0 ms .

2.Promise can be used with any async callback implementations.


Promise Implemenation / Promise Objects:
........................................

1. Create Promise Object from Promise contructor
        new Promise()
2. Create Promise object from factory apis
   ClassName.getInstance()===Object
	Promise.resolve() ==>Promise
        Promise.reject() ===>Promise




Promise object methods:
1.then - success
2.catch - errors
3.finally - clean up
4.resolve
5.reject
6.all
7.race


///////////////////////////////////////////////////////////////////////////////////////////

                   When to use factory api and when to use constructor 
				to create Promise Object




//Promise implementation:
/**
 * 1.Promise is object is created in two ways
 *  -factory methods
 *     resolve
 *     reject
 *  -constructors
 *    new Promise()
 * Promise by default is async, it uses setTimeout with 0ms
 */

//callback 
// function delay(handler) {
//     let fakeData = "Hello!How areyou"
//     //timer logic
//     setTimeout(handler, 5000, fakeData);
// }

// console.log('start')
// delay(function (data) {
//     console.log(`${data}`)
// });
// console.log('stop');

function delay() {
    let fakeData = "Hello Promise";
    //return promise only
    //  setTimeout(handler, 0, fakeData);
    return Promise.resolve(fakeData); //new Promise Object with success 
}

console.log('start')
delay().then(data => console.log(data));
console.log('stop');


function delayWithError() {
    let fakerError = "boom!!";
    //return promise only
    //  setTimeout(handler, 0, fakeData);
    return Promise.reject(fakerError); //new Promise Object with Error 
}
delayWithError().catch(err => console.log(err));

//with biz logic  , resolve and reject

function delayWithBiz() {
    let user = {
        id: 1,
        name: 'admin'
    };
    let error = {
        code: 500,
        message: 'boom!! No User found'
    }
    if (user) {
        return Promise.resolve(user)
    }
    return Promise.reject(error);
}
delayWithBiz()
    .then(user => console.log(user))
    .catch(err => console.log(err))
    .finally(() => console.log('done!!!!'))
////////////////////////////////////////////////////////////////////////////////////
//Promise Constructor pattern

function getPromiseWithMoreDelay() {

    return new Promise((resolve, reject) => {
        let user = {
            id: 1,
            name: 'admin'
        };
        let error = {
            code: 500,
            message: 'boom!! No User found'
        }
        if (user) {
            setTimeout(resolve, 5000, user);
        } else {
            setTimeout(reject, 5000, error);

        }

    });
}

getPromiseWithMoreDelay()
    .then(user => console.log(user))
    .catch(err => console.log(err))
    .finally(() => console.log('done!!!!'))


//how to refactor callback nesting using promise; how to avoid callback hell.

const { log } = console;

const getUser = () => {
    return new Promise((resolve, reject) => {
        let user = {
            id: 1,
            name: 'admin'
        };
        let err = {
            code: 500,
            message: 'User not Found!!'
        }

        if (user) {
            setTimeout(resolve, 1000, user);
        } else {
            setTimeout(reject, 1000, err);
        }
    })

};

//login method takes 3 args -  user

const login = user => {
    //biz logic
    return new Promise((resolve, reject) => {
        const SUCCESS = 'Login success';
        const FAILURE = 'Login Failed';
        if (user.name === 'admin') {
            setTimeout(resolve, 1000, SUCCESS)
        } else {
            setTimeout(reject, 1000, FAILURE);
        }
    })

};

//callback hell
// getUser(user => {
//     //nesting 
//     log('User is called')
//     login(user, success => {
//         log(success);
//     }, failure => {
//         log(failure);
//     });
// }, err => {
//     log(err);
// });

//callback hell solution : promise
//way -1

getUser()
    .then(user => {
        login(user)
            .then(status => {
                console.log(status);
            })
            .catch(err => console.log(err))
    })
    .catch(err => console.log(err))
    .finally(() => console.log('done!!'))

//way 2
getUser()
    .then(user => {
        return login(user)
    })
    .then(status => console.log(status))
    .catch(err => console.log(err))
    .finally(() => console.log('done!!'))

//way 2.1
getUser()
    .then(user => login(user))
    .then(status => console.log(status))
    .catch(err => console.log(err))
    .finally(() => console.log('done!!'))
//way 2.2
getUser()
    .then(user => login(user))
    .then(log)
    .catch(log)
    .finally(() => console.log('done!!'))

// getUser(user => {
//     //nesting 
//     log('User is called')
//     login(user, log, log);
// }, log);
**********************************************************************************************


getUser()
    .then(user => login(user))
    .then(status => console.log(status))
    .catch(err => console.log(err))
    .finally(() => console.log('done!!'))
//way 2.2
getUser()
    .then(user => login(user))
    .then(log)
    .catch(log)
    .finally(() => console.log('done!!'))


Questions:

1.Whether this code is able to understand quickly
2.Whether this code is able to debug
3.Whehter this code is scalable?
4.whether this code is maintaiable?

 "Problem" : Promise Hell.

Solution : ES 7 Introduced  how to handle promises from callerside :

  -async .... await  => keywords makes promise handling simpilar like sync calls.


Callee                                     Caller

returns Promise                             then..catch

returns Promise                             async await..



/////////////////////////////////////////////////////////////////////////////////////////////

1.async functions


/**
 * async function
 *   -it is normal function only , returns promise.resolve by default
 */

// function getData(){
//     return Promise.resolve('Hello');
// }
//async function
async function getData() {
    return 'Hello'; //Promise.resolve('Hello');
}
getData().then(data => console.log(data));

//resolve,reject
async function getDataWithLogic() {
    let user = {
        id: 1,
        name: 'admin'
    }
    if (user) {
        return user;
    } else {
        Promise.reject({ code: 500, message: 'User not found!' })
    }
}
getDataWithLogic()
    .then(data => console.log(data))
    .catch(err => console.log(err))
/////////////////////////////////////////////////////////////////////////////////
//callee
const getUser = () => {
    return new Promise((resolve, reject) => {
        let user = null;
        let err = {
            code: 500,
            message: 'User not Found!!'
        }

        if (user) {
            setTimeout(resolve, 1000, user);
        } else {
            setTimeout(reject, 1000, err);
        }
    })

};

//caller
async function caller() {
    // getUser()
    // .then(data => console.log(data))
    // .catch(err => console.log(err))
    try {
        let user = await getUser();
        console.log(user);
    }
    catch (err) {
        console.log(err);
    }
    finally {
        console.log('done!!');
    }
}
caller()
*********************************************************************************************

node modules:

types of node modules:

1.custom node modules -  discussed
2.built in modules
3.thrid party modules



built in modules:

 node provides lot of built node modules for building node applications.

note: any module , at end js only.

basic nodules

1.os
2.event emitter
3.io modules
  -fs
  -http

os : operating system.

//os module

const { arch,cpus } = require('os') // os.js

console.log(arch())
console.log(cpus())
//////////////////////////////////////////////////////////////////////////////////////////////
node_modules folder:
....................

 require('./OrderRepository');
  ->here you can see ./
  ./ -current dir
 require('os'); => 
  -here no ./ 
 
Why?

Note : if you are java dev, you know the classpath , how it works?


require('os');
 if you dont tell with './'

    Node internally uses a search algorthim,node always looks the folder called
 "node_modules" in the current project, if not , then it searches, the node in built installtion folder---c:/pf/node/node_nodules--if it finds it will pick up from there else it will throw error.

internal/modules/cjs/loader.js:800
    throw err;
    ^

Error: Cannot find module 'osxx'
Require stack:
- C:\session\ibm\july\nodems\mynode-apps\src\index.js
[90m    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:797:15)[39m
[90m    at Function.Module._load (internal/modules/cjs/loader.js:690:27)[39m
[90m    at Module.require (internal/modules/cjs/loader.js:852:19)[39m
[90m    at require (internal/modules/cjs/helpers.js:74:18)[39m
    at Object.<anonymous> (C:\session\ibm\july\nodems\mynode-apps\src\index.js:3:23)
[90m    at Module._compile (internal/modules/cjs/loader.js:959:30)[39m
[90m    at Object.Module._extensions..js (internal/modules/cjs/loader.js:995:10)[39m
[90m    at Module.load (internal/modules/cjs/loader.js:815:32)[39m
[90m    at Function.Module._load (internal/modules/cjs/loader.js:727:14)[39m
[90m    at Function.Module.runMain (internal/modules/cjs/loader.js:1047:10)[39m {
  code: [32m'MODULE_NOT_FOUND'[39m,
  requireStack: [ [32m'C:\\session\\ibm\\july\\nodems\\mynode-apps\\src\\index.js'[39m ]

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Event Emitter:

 It is used to build driven programming.
 In node js most io applications are event driven.

Here we are going to talk how to write custom events.




//Event driven programming ; using events module

const EventEmitter = require('events');

//Create Event object
const events = new EventEmitter();

//subscriber
events.on('hello', data => {
    console.log(data);
});

//publisher
function producer() {
    //emit /send event to subscribers
    events.emit('hello', 'Hello!!!');
}
producer();
//////////////////////////////////////////////////////////////////////////////

//domain class
class OrderService extends EventEmitter {
    constructor() {
        super();
        this.on('orderCreated', order => console.log(order))
    }
    //methods
    sale(order) {
        //when ever sale is called
        this.emit('orderCreated', order);
    }
}

let orderService = new OrderService();

setTimeout(() => {
    orderService.sale({ id: 1, produt: 'A', price: 9000 });
}, 1000)

********************************************************************************************
IO: Non blocking:
//file system io
const fs = require('fs');

//read file : non blocking

const filePath = './src/assets/info.txt';
const options = {
    encoding: 'UTF-8'
};
const handler = function (err, data) {
    if (err) throw err;
    console.log(data);
};
console.log('start')
fs.readFile(filePath, options, handler);

//inline hander
fs.readFile(filePath, options, (err, data) => {
    if (err) throw err;
    console.log(data);
});

console.log('end');



const FileService = require('./api/FileService');


let fileService = new FileService();

async function readTextFile() {
    //read File 
    fileService.readFile(data => console.log(data));
    //promise pattern
    fileService.readFilePromise()
        .then(data => console.log(data))
        .catch(err => console.log(err))

    try {
        let data = await fileService.readFilePromise();
        console.log('Await result' + data);
    }
    catch (err) {
        console.log(err);
    }

}
readTextFile();


const fs = require('fs');

class FileService {
    constructor() {

    }
    //callback pattern
    readFile(handler) {
        const filePath = './src/assets/info.txt';
        const options = {
            encoding: 'UTF-8'
        };
        fs.readFile(filePath, options, (err, data) => {
            if (err) throw err;
            //  console.log(data);
            handler(data);
        });
    }
    //Promise pattern
    readFilePromise() {
        return new  Promise((resolve, reject) => {
            const filePath = './src/assets/info.txt';
            const options = {
                encoding: 'UTF-8'
            };
            fs.readFile(filePath, options, (err, data) => {
                if (err) {
                    reject(err);
                }
                //  console.log(data);
                resolve(data);
            });
        });
    }
}
module.exports = FileService;


******************************************************************************************

how to write file

//fs.js : non block io
const fs = require('fs');

//write file
const writeFilepath = './src/assets/info-copy.txt';

const data = 'This is node IO file!';

console.log('start')

fs.writeFile(writeFilepath, data, function (err) {
    if (err) throw err;
    console.info(`The file ${writeFilepath} has been written!`)
});
console.log('end')
********************************************************************************************

Does node support blocking IO?

   Blocking io means , io operations are handled by node itself, not os kernal threads.

Node supports some what blocking io.

Node's libuv offers thread pools for handling blocking ios.

Note : dont over use blocking io.

Node blocking io Operations:
.........................

fs.readFileSync()
fs.writeFileSync()

const fs = require('fs');

const filePath = './src/assets/info.txt';
const config = {
    encoding: 'UTF-8'
}

console.log('start');
const data = fs.readFileSync(filePath, config);
console.log(data);
console.log('end')

********************************************************************************************

Global Variables:

1.__dirname
      ->Get current dir path
2.__filename
     ->Get current dir + path__filename
     ->Get current dir + path

path module
The path module provides utilities for working with file and directory paths in platform
independant way.

const fs = require('fs');
const path = require('path');

  
//file system io
const fs = require('fs');
const path = require('path');


//read file : non blocking

//const filePath = './src/assets/info.txt';
const filePath = path.join(__dirname,'assets/info.txt');
const options = {
    encoding: 'UTF-8'
};
const handler = function (err, data) {
    if (err) throw err;
    console.log(data);
};
console.log('start')
fs.readFile(filePath, options, handler);

//inline hander
fs.readFile(filePath, options, (err, data) => {
    if (err) throw err;
    console.log(data);
});

console.log('end');
*********************************************************************************************
IO Streaming:
............
Evented IO :  Event driven io.
..............................

Async io operations can be done two ways.

1.Non-Streaming
2.Streaming  : Evented IO : Event driven IO.

Non Streaming IO : read / write

non streaming vs streaming:

 The operating system completes the whole file read operation, sends to node process memory  , and finally will be delivered to user
  if more files , then process will be halt.

Non streaming apis are not suitable for network concurrent file operations.


non streaming file apis

 fs.readFile
 fs.writeFile
 etc.....

Solution : Stream file apis:
...........................


Packet===breaking content into smaller units each unit is called packet.

node breaks content into smaller unit called "chunk"
node streams /send data in order chunk by chunk.


Types of Streams:

1.Readaable Stream : input
2.Writeable stream : output
3.Duplex stream : read + output


Built in readable Streams:

HTTP responses, on the client
HTTP requests, on the server
fs read streams
zlib streams
crypto streams
TCP sockets
child process stdout and stderr
process.stdin

Writable Streams:

HTTP requests, on the client
HTTP responses, on the server
fs write streams
zlib streams
crypto streams
TCP sockets
child process stdin
process.stdout, process.stderr

All streaming apis are powered with events
node io streams has built in events.
events are emitted by node.
Our programs are listeners


Streams and Events:

 emitters are os
 listerners are our programs

on method : use for listening io events
emit---we dnt use

common events in all io

data event:
 which is emitted by node, for each chunk.

close event:
  The 'close' event is emitted when the stream and any of its underlying resources (a file descriptor, for example) have been closed.

end event:
The 'end' event is emitted when there is no more data to be consumed from the stream.

Event: 'error'
 The 'error' event may be emitted by a Readable implementation at any time
Typically, this may occur if the underlying stream is unable to generate data due to an underlying internal failure, or when a stream implementation attempts to push an invalid chunk of data.

//how to read /write file using streams
//streams are powered events : evented io
const fs = require('fs')
const path = require('path');
const { log } = console;

const fileName = path.join(__dirname, 'assets/info.txt');
const config = {
    encoding: 'UTF-8'
}

const fs = require('fs')
const path = require('path');
const { log } = console;

const fileName = path.join(__dirname, 'assets/info.txt');
const config = {
    encoding: 'UTF-8'
};

//create Read stream
const inputStream = fs.createReadStream(fileName, config);

//starts attaching listerners
//data event is emitted by os for each chunk of data

let data = '';
inputStream.on('data', chunk => {
    log(`Received ${chunk.length} bytes of data.`)
    //log(chunk)
    data += chunk;
})

//end event is called , no more chunk of data is availble.
inputStream.on('end', () => {
    log('end is called');
    log(data);
})

//error event: for error handling
inputStream.on('error', err => {
    log('error')
});

const fs = require('fs');
const path = require('path');

const fileName = path.join(__dirname, 'assets/grains.txt');

const config = {
    encoding: 'utf8',
    flag: 'w'
};
const grains = ['wheat', 'rice', 'oats'];

const outputStream = fs.createWriteStream(fileName, config);

while (grains.length) {
    let data = grains.pop() + " ";
    outputStream.write(data);
    console.log("Wrote: %s", data);
}
outputStream.close();

outputStream.on('close', function () {
    console.log('file has been closed ')
});

******************************************************************************************

How to read from one file and write into file? ===> Read + Write:
.................................................................

//Read + write : simple eg:
//read + write
const fs = require('fs');
const path = require('path');

//read
const inputfileName = path.join(__dirname, 'assets/info.txt');
//write
const outputFileName = path.join(__dirname, 'assets/greeter.txt');

const config = {
    encoding: 'UTF-8'
}

const inputStream = fs.createReadStream(inputfileName, config);
const outputStream = fs.createWriteStream(outputFileName, config);

//Register data event.
inputStream.on('data', function (chunk) {
    console.log(`Received ${chunk.length} bytes of data.`);
    console.log(chunk);
    //writing data chunk by chunk
    outputStream.write(chunk);
});


//end event
inputStream.on('end', function () {
    console.log('There will be no more data to read!');
    outputStream.close();
})

//error event: for error handling
inputStream.on('error', function (err) {
    console.log(`Some thing went wrong! ${err}`)
});

outputStream.on('close', function () {
    console.log(`File write operation is completed`);
});
*************************************************************************************
Back Pressure: read + write  === read + process +write ===  (f1--f2--f3--)
............................................................................


Back Pressure:
..............
Problems when you do read and write together

1. In general read operation is faster than write operation


Back Pressure means inputstream is fast, outputstream slow, then data will be
lost.


in order to show back pressure, we need big file.

big file creation code:
.......................

const fs = require('fs');
const path = require('path')

const filePath = path.join(__dirname, "assets/big.file")
const file = fs.createWriteStream(filePath);

for (let i = 0; i <= 1e6; i++) {
    file.write('Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n');
}

file.end();



Handling back pressure:
.......................
Pause Input stream if the Node Process memory is full(Buffer),resume if buffer/process memory is empty.

stream.pause() if stream is full
else
stream.resume() if stream is drain

drain event is called if buffer is empty.


const fs = require('fs');
const path = require('path');

const inputfileName = path.join(__dirname, 'assets/big.file');
const outputfileName = path.join(__dirname, 'assets/big_copy.file');

const config = {
    encoding: 'UTF-8'
}

//Back pressure handling
const readerStream = fs.createReadStream(inputfileName, config);
const writeStr = fs.createWriteStream(outputfileName, config);

readerStream.on('data', function (chunk) {
    console.log(`Received ${chunk.length} bytes of data.`);

    //test if buffer is full or not
    let buffer_good = writeStr.write(chunk);

    if (!buffer_good) readerStream.pause();
});
writeStr.on('drain', function () {
    console.log('buffer drained!');
    readerStream.resume();
});

readerStream.on('end', function () {
    //console.log(data);
});

readerStream.on('error', function (err) {
    console.log(err.stack);
});
/////////////////////////////////////////////////////////////////////////////////////////////

read and write without data loss.
...................................

pipe method : 
  it is abstraction method for pasue,resume,drain.

const fs = require('fs');
const path = require('path');

const inputfileName = path.join(__dirname, 'big.file');
const outputfileName = path.join(__dirname, 'big_copy.file');

const config = {
      encoding: 'UTF-8'
}

//Back pressure handling
const readerStream = fs.createReadStream(inputfileName, config);
const writeStr = fs.createWriteStream(outputfileName, config);

//backPressure streams
//pipe method is simplest method which wraps resume,pasuse,drain 
readerStream.pipe(writeStr);
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Service :
  return promise where array 
  convert into json write into file.......
*********************************************************************************************
Non Blocking Networking:

TCP/IP
DataGram
HTTP


1.HTTP:

 module is used to communicate http protocal , where we can build web apps.


Web Apps in Node:
................

Tradtional web work flow

Client-----request----------------WebServer--- thread--will io operation.
Client-----request----------------WebServer----thread--will io operation.
Client-----request----------------WebServer---thread-- will io operation.
Client-----request----------------WebServer---thread-- will io operation.



Non Blocking web model(Node.js):
...............................

Client-----request------WebServer built by node---|-            will io operation.
Client-----request------WebServer built by node---|- libvu --os will io operation.
Client-----request----- WebServer built by node---|-            will io operation.
Client-----request----- WebServer built by node---|-            will io opeeration


node and http 
node provides http high level api from 'http.js' through module.


//create web server
//create web app

//start the webserver


class:http:ServerResponse : output
class:http:ClientRequest : input
class:http:Server : handling low level socket operations

HTTP is streaming api, backpressure can be handled, data is chunked.


const http = require('http');

const { log } = console;

const port = 3000;

/**
 * webserver
 * webapp
 * deployment
 */
//web server and web application

//webapp is represented by funciton - listener /handler function
//here request and response are just variables holding , the instance of ClientRequest
//and ServerResponse classes.

//handles client request and response in nonblocking way.
const httpListener = (request, response) => {
    //write data into response stream 
    response.write('<h1>Hello Node Web App!</h1>');
    //close the current connection
    response.end();

    //response events
    response.on('close', () => {
        //perform something when server is closed
        log(`Server is closed...`)
    })
    response.on('finish', () => {
        //perform something when server is closed
        log(`Server has committed response`);
    })

};
const server = http.createServer(httpListener);

//server events
server.on('request', (request, response) => {
    log(`Client request on  ${new Date()}`)
});

//start the server
server.listen(port, () => {
    log(`Server listens at ${port}`);
})


const http = require('http');
const TodoService = require('./api/TodoService');

const { log } = console;

//create todo object
const todoService = new TodoService();

const port = 3000;

const httpListener = async (request, response) => {
    //write data into response stream 
    response.writeHead(200, {
        'Content-Type': 'application/json'
    });
    let todos = await todoService.findAllAsyncWithPromise();
    response.write(JSON.stringify(todos));
    //close the current connection
    response.end();

};
const server = http.createServer(httpListener);

//server events
server.on('request', (request, response) => {
    log(`Client request on  ${new Date()}`)
});

//start the server
server.listen(port, () => {
    log(`Server listens at ${port}`);
})
**************************************************************************************

const http = require('http');
const TodoService = require('./api/TodoService');

const { log } = console;

//create todo object
const todoService = new TodoService();
const port = 3000;

//request and reponse represents a stream ; duplex stream
//input and output streams.

const server = http.createServer((request, response) => {

    //echo use case
    //attach request event - data 
    let data = '';
    request.on('data', (chunk) => {
        log('request event is called')
        data += chunk;
    });
    request.on('end', () => {
        log(data);
        response.write(data);
        response.end();
    });

});

//server events
server.on('request', (request, response) => {
    log(`Client request on  ${new Date()}`)
});

//start the server
server.listen(port, () => {
    log(`Server listens at ${port}`);
})
**********************************************************************************************

What if i want to build rest full web services

 -Resource mapping
  -GET,POST,DELETE,PUT,.....
  -/api/list
  -/api/:id

Using core http module, it is very diffcult to build realtime web apps and webservices.
 why, developers, need to focus resource and url mapping and application.

Solution : frameworks.

there are lot of node based web frameworks available in the market.

*******************************************************************************************

Thrid party modules and npm : node package manager:
...................................................

node modules types
1.custom module - discussed
2.in built modules - disucssed
3.third party modules - 

npm:   
 node package manager === mvn
npm is tool is used to distribute node modules to others
and you can get node modules from  others.

npm tool is distributed along with node installation

npm uses public repository server called npmjs.com npmjs.org

tools and libs,frameworks all are distributed as node modules into repository.


Core concepts of npm :

->used to pull and push node modules into npmjs.com 

Javascript Project Structure:(server side/ client side)
.........................................................

The project must have two things

1.package.json file :
   meta file which describes the project information
2.node_modules folder
   which contains libs/frameworks/tools code.



Steps always to create js projects

- create package.json file first

create package.json file

>npm init


{
  "name": "mynode-apps",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Subramanian Murugan",
  "license": "ISC"
}


npm is used

to install,uninstall,publish node modules from node repo / into node repo.

if you install third party modules , into your project, node distributes npm tool ,using this you can install,uninstall,upgrade node modules.


npm syntax:

npm commandName.

where <command> is one of:
    access, adduser, audit, bin, bugs, c, cache, ci, cit,
    clean-install, clean-install-test, completion, config,
    create, ddp, dedupe, deprecate, dist-tag, docs, doctor,
    edit, explore, fund, get, help, help-search, hook, i, init,
    install, install-ci-test, install-test, it, link, list, ln,
    login, logout, ls, org, outdated, owner, pack, ping, prefix,
    profile, prune, publish, rb, rebuild, repo, restart, root,
    run, run-script, s, se, search, set, shrinkwrap, star,
    stars, start, stop, t, team, test, token, tst, un,
    uninstall, unpublish, unstar, up, update, v, version, view,
    whoami

node_modules : folder which can hold all javascript modules downloaded from repo.


installing module:

>npm install  moduleName  --options
>npm i moduleName --options

options:
 --save
 --save-dev
 -g

Development

Production

if you are installing any node module, you can tell, do you want to use only for development
or development + production.

Unit testing libs : Junit.jar===>

 --save = >    development + production
 --save-dev => only for development

********************************************************************************************

Development and production modules:

1.lodash

npm init -one time

>npm install lodash --save


index.js

let util = require('lodash/array');
//start using lodash
const array = [1];
const other = util.concat(array, 2, [3], [[4]]);
console.log(other);

*********************************************************************************************
Only Development,Testing

Unit Testing
E2e Testing
compilers
tools 

->npm install module --save-dev

-chai.js

 "dependencies": {
    "lodash": "^4.17.19"
  },
  "devDependencies": {
    "chai": "^4.2.0"
  }

npm install --save-dev jasmine

****************************************************************************************

how to uninstall

npm uninstall --save-dev jasmine


**********************************************************************************************

Global dependencies:

Tools and Technologies:
.......................

1.compiler
2.build system
3.servers
4.cli tools to create and manage projects

Tool:
.....
1.mocha : server for testing 


global modules are installed globally not inside project

 C:\Users\sasub\AppData\Roaming\npm\node_modules\mocha\bin\mocha
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Automation:
  Java script automation.

package.json contains "scripts" used for automation.

 "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },

key:value
 |       | 
command  task to be executed

commands:

1.built in commands
 test,start,stop.....
   
"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
     "start" : "node src/httpserver-1.js"
  }
how to execute?
 > npm start  | npm test

2.user defined commands

command name can be user defined.

subu

"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node src/httpserver-1.js",
    "subu": "node src/httpserver.js "
  }

How to run?
npm run subu ; just add run command for user defined commands.


how to run /chain multiple "tasks" together using single command?
  Yes possible ; kindly refer npm scripts section 

Global dependencies and scripts , problems with Global dependencies:
....................................................................

1.version mismatches for various  projects


Soution :

1.install any tools as dev dependency inside project

npm install mocha --save-dev


2.can i run mocha like below 
C:\session\ibm\july\nodems\mynode-apps>mocha

 No! because mocha is not in globally rather in project specfic.

3.how to run mocha command 
  soultion is Scripts.

  "scripts": {
    "test": "mocha",
    "start": "node src/httpserver-1.js",
    "subu": "node src/httpserver.js "
  }
***********************************************************************************************
Express Js:

create project 

npm init

npm install express --save


Express :

1. express is framework built on core http module.
const express = require('express');

Express core objects:

1.Application
2.Request
3.Response
4.Router

Application is core container object, which contains other objects used to build web apps.
entry point of express.

Steps;

1.create application object

//create application object
const app = express();

2.start server
const port = 3001;
app.listen(port, () => console.log('Express server is Ready!'));




//get express , returns a function/class ; to create object-application object
const express = require('express');

const port = 3001;

//create application object
const app = express();

//Request and Response hanndling : router based -HTTP Method  and url mapping is simpe

//home path
app.get('/', (request, response) => {
    response.end('<h1>Welcome to My Application</h1>')
});
//TODO API
app.get('/api/todo/list', (request, response) => {
    response.end('todo list : get')
})
app.post('/api/todo', (request, response) => {
    response.end('todo list : Post')
})
app.delete('/api/todo', (request, response) => {
    response.end('todo list : delete')
})
app.put('/api/todo', (request, response) => {
    response.end('todo list : puts')
})

//server starts
app.listen(port, () => console.log('Express server is Ready!'));

*********************************************************************************************
Resource mapping:

api 
  todos
    -get,post,delete,put
  users
   -get,post,delte,put
  products
  customers

Express modularity:

 express isloates code via special object called routers.

const express = require('express');

//create Router instance
const todoRouter = express.Router();

todoRouter.get('/list', (request, response) => {
    response.end('todo list : get')
})
todoRouter.post('/', (request, response) => {
    response.end('todo list : Post')
})
todoRouter.delete('/', (request, response) => {
    response.end('todo list : delete')
})
todoRouter.put('/', (request, response) => {
    response.end('todo list : puts')
})

module.exports = todoRouter;


const express = require('express');
const userRouter = express.Router();

userRouter.get('/list', (request, response) => {
    response.end('users list : get')
});
userRouter.post('/', (request, response) => {
    response.end('users list : Post')
})
userRouter.delete('/', (request, response) => {
    response.end('todo list : delete')
})
userRouter.put('/', (request, response) => {
    response.end('users list : puts')
})

module.exports = userRouter;


//get express , returns a function/class ; to create object-application object
const express = require('express');
const todoRouter = require('./routers/todos');
const userRouter = require('./routers/users')

const port = 3001;

//create application object
const app = express();

//Link with Routers
app.use('/api/todos', todoRouter);
app.use('/api/users', userRouter);


//home path
app.get('/', (request, response) => {
    response.end('<h1>Welcome to My Application</h1>')
});

//server starts
app.listen(port, () => console.log('Express server is Ready!'));

*********************************************************************************************

const express = require('express');
//const todoservice = require('../services/TodoService');
const { findAll } = require('../services/TodoService');

//create Router instance
const todoRouter = express.Router();

todoRouter.get('/list', async (request, response) => {
    //json
    // let todos = await todoservice.findAll()
    let todos = await findAll();
    response.json(todos);

})
todoRouter.post('/', (request, response) => {
    response.end('todo list : Post')
})
todoRouter.delete('/', (request, response) => {
    response.end('todo list : delete')
})
todoRouter.put('/', (request, response) => {
    response.end('todo list : puts')
})

module.exports = todoRouter;


const TODOS = require('../data/todos')

class TodoService {
    constructor() {
    }
    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 5000, TODOS)
        });
    }
}

//export object
module.exports = new TodoService();

***********************************************************************************************
Middlewares:
...........

What is middleware?
 middleware is a javascript function which provides utilties

filters : in java servlets eq middleware.

Express app architecture:

express has two things
1.URL mapping and request processing : app.get('url')
2.Routers , to create moduels


Extra features 
1.logging
2.auth
3.database
4.session
5.data parsing
6.templates
etc....................

How to integrate theses features into express app.

express says i can provide only routing,req and response process, if you want anything ,
with "Middlewares"

Types of middlewares
1.custom middlewares
2.third party middlewares

middleware workflows:

client----request---node--server---express application---

			   | ---m1
			   | --m2
	express application| ---m3   ----Request Processing(get,post...)
			   |---m4
			   | --mn


 Note : middleware code is executed before/after request-response handling


How to attach middleware with application object /Router level?

app.use(middleware) : middleware registeration at app level : global middlewares
router.use(middleware) : middleware registeration at module level


Types of middlewares based on Use:
.................................
Application-level middleware
  middleware attached at application : global middlewares
Router-level middleware
 middleware attached at router level(module) : module specific
Error-handling middleware
 for handling global errors
Built-in middleware
 provided by express itself
Third-party middleware
 provided by others.

Built-in middleware
 provided by express itself

1.body-parser :
  which parses client input data into javascript object

 npm install body-parser --save


//get express , returns a function/class ; to create object-application object
const express = require('express');
const bodyParser = require('body-parser')

const port = 3001;

const { log } = console;
//create application object
const app = express();

// parse application/x-www-form-urlencoded
app.use(bodyParser.urlencoded({ extended: false }))

// parse application/json
app.use(bodyParser.json())

/////////////////////////////////////////////////////////////////////////////////////

//home path
app.get('/', (request, response) => {
    response.end('<h1>Welcome to My Application</h1>')
});
//request payload
app.post('/api/greet', (request, response) => {
    // let data = '';
    // request.on('data', (chunk) => {
    //     log('request event is called')
    //     data += chunk;
    // });
    // request.on('end', () => {
    //     log(data);
    //     response.end(data);
    // });

    let data = request.body;
    log(data);
    response.json(data);


})

//server starts
app.listen(port, () => console.log('Express server is Ready!'));
///////////////////////////////////////////////////////////////////////////////////////////

custom middleware:
 -app level
 -app level with url mapping ,http methods
 -router level
 -router url mapping

i want to call middlware for whole application irrespective of routers,urls,methods.
  -global middlewares

middleware is function , takes 3 args - req,res,next
next is function used to move the middleware from one to another .
 
 req -- m1-next--m2-next-m3-next-mN - response


//get express , returns a function/class ; to create object-application object
const express = require('express');
const bodyParser = require('body-parser')
const todoRouter = require('./routers/todos');


const port = 3001;

const { log } = console;
//create application object
const app = express();

////////////////////////////////////////////////////////////////////////////////
//custom global middleware
app.use((req, res, next) => {
    //middleware logic
    log(`Request received from ${req.url} on ${req.method}`)
    //at end you have to call
    next();
});
////////////////////////////////////////////////////////////////
app.use('/api/todos', todoRouter);
////////////////////////////////////////////////////////////////////////////////
// parse application/x-www-form-urlencoded
app.use(bodyParser.urlencoded({ extended: false }))

// parse application/json
app.use(bodyParser.json())

/////////////////////////////////////////////////////////////////////////////////////

//home path
app.get('/', (request, response) => {
    response.end('<h1>Welcome to My Application</h1>')
});
//request payload
app.post('/api/greet', (request, response) => {
    // let data = '';
    // request.on('data', (chunk) => {
    //     log('request event is called')
    //     data += chunk;
    // });
    // request.on('end', () => {
    //     log(data);
    //     response.end(data);
    // });

    let data = request.body;
    log(data);
    response.json(data);


})

//server starts
app.listen(port, () => console.log('Express server is Ready!'));

****************************************************************************************


const express = require('express');
//const todoservice = require('../services/TodoService');
const { findAll } = require('../services/TodoService');

//create Router instance
const todoRouter = express.Router();

todoRouter.use((req, res, next) => {
    //middleware logic
    console.log(`todos middleware called`)
    //at end you have to call
    next();
});

todoRouter.get('/list', async (request, response) => {
    //json
    // let todos = await todoservice.findAll()
    let todos = await findAll();
    response.json(todos);

})
todoRouter.post('/', (request, response) => {
    response.end('todo list : Post')
})
todoRouter.delete('/', (request, response) => {
    response.end('todo list : delete')
})
todoRouter.put('/', (request, response) => {
    response.end('todo list : puts')
})

module.exports = todoRouter;

*********************************************************************************************

Data base integration with express:
..................................

mongodb driver

npm install mongojs


ProductService
const db = require('../connection');

class ProductService {
    constructor() {
    }
    findAll() {
        return new Promise((resolve, reject) => {
            const products = db.collection('products');
            //query monogodb
            products.find((err, docs) => {
                if (err) {
                    reject(err)
                }
                resolve(docs);
            })
        });
    }
}

//export object
module.exports = new ProductService();

*******************************************************************************

src/connection.js


const mongojs = require('mongojs');

const db = mongojs('Myproductsdb1')
module.exports = db;

******************************************************************************************

productrouter.js



const express = require('express');
const { response } = require('express');
const { findAll } = require('../services/ProductService');

const productRouter = express.Router();

productRouter.get('/list', async (request, response) => {
    let products = await findAll();
    response.json(products);
});

module.exports = productRouter;



******************************************************************************************************
app.js

//get express , returns a function/class ; to create object-application object
const express = require('express');
const todoRouter = require('./routers/todos');
const userRouter = require('./routers/users')
const productRouter =require('./routers/products');


const port = 3001;

//create application object
const app = express();

//Link with Routers
app.use('/api/todos', todoRouter);
app.use('/api/users', userRouter);
app.use('/api/products', productRouter);

//home path
app.get('/', (request, response) => {
    response.end('<h1>Welcome Product Application</h1>')
});

//server starts
app.listen(port, () => console.log('Express server is Ready!'));

******************************************************************************************

TCP/IP,DNS,UDP
.............

TCP/IP:
 -net modules.

server.js
// Include Nodejs' net module.
const Net = require('net');
// The port on which the server is listening.
const port = 1337;

// Create a new TCP server.
const server = new Net.Server();

server.listen(port,function(){
    console.log(`Server listening for connection requests on socket localhost:${port}`);
});
// When a client requests a connection with the server, the server creates a new
// socket dedicated to that client.
// When a client requests a connection with the server, the server creates a new
// socket dedicated to that client.
server.on('connection', function(socket) {
    console.log('A new connection has been established.');

    // Now that a TCP connection has been established, the server can send data to
    // the client by writing to its socket.
    socket.write('Hello, client.');

    
    // // The server can also receive data from the client by reading from its socket.
    socket.on('data',function(chunk){
            console.log(`Data received from client: ${chunk.toString()}`);
    });

      // When the client requests to end the TCP connection with the server, the server
    // ends the connection.
    socket.on('end', function() {
        console.log('Closing connection with the client');
    });

    // Don't forget to catch error, for your own sake.
    socket.on('error', function(err) {
        console.log(`Error: ${err}`);
    });
  
});

client.js
var net = require('net');

var client = new net.Socket();

client.connect(1337, 'localhost', function() {
	console.log('Connected');
	client.write('Hello, server! Love, Client.');
});

client.on('data', function(data) {
	console.log('Received: ' + data);
	client.destroy(); // kill client after server's response
});

client.on('close', function() {
	console.log('Connection closed');
});
**********************************************************************************************

DNS ACCESS:

const dns = require('dns');  

dns.resolve4('www.google.com', (err, addresses) => {  
  if (err) throw err;  
  console.log(`addresses: ${JSON.stringify(addresses)}`);  
  addresses.forEach((a) => {  
    dns.reverse(a, (err, hostnames) => {  
      if (err) {  
        throw err;  
      }  
      console.log(`reverse for ${a}: ${JSON.stringify(hostnames)}`);  
    });  
  });  
});  
********************************************************************************************

MicroServices on Node JS:
.........................

What is Micro service?

 Micro service is one of software enginerring principle
 to build distributed application.

 Microservice is one of software architecture pattern
 to build distribtued applications

Distributed Applications:

The components(parts) of the application is distributed across different machines. 
They communicate each other to exchange data.

Distributed application dev patterns:
....................................

1.Monolithic architecture
2.Microservice architecture


1.Monolithic architecture

The application is developed and deployed as single Java WAR/EAR/JAR file.
a single directory hierarchy of Rails or NodeJS code

Single dev,testing,deployment.

Draw backs:

1.what if i want to deliver project to end clients module by module at period intervals

2.Vendor lock in
   if you select one technolgy like java /mysql, the whole application must be in java only.
   polyglot not possible.
3.Scalablity 
   If you want dev/enchance your application based on modern biz needs, it is difficult
etc...

Micro service :

 Break the whole application into a "separate application"

Each application can be develped,tested, deployed separatly 
  Domain driven design : Build application based on domain only not for technology 
  SOLID 

//////////////////////////////////////////////////////////////////////////////////////////

Micro Service :

  As a developer , you have to concentrate lot of things.

1. coding
2. infra structure 
    ->How to manage source code repo :git /svn /bit bucket
    ->How to work with CI/CD 
    ->Deployments
         Dockers,KB....
    ->Communication infra
        ->RPI
        ->Messaging : MOM
	->domain specific : TCP/IP ,HTTP,SMTP
   ->Software Registry
       ->Service registry
       ->Service discovery
   ->API Gateways

   ->Reliability
	->Fallabck
        -circuiteBreaker

Observability /Management
	->Log aggregation	
	Application metrics
	Audit logging
	Distributed tracing
	Exception tracking
	Health check API
	Log deployments and changes

  Security
       token

Centeralized configuration

DataBase,Transaction
.............................................................................................
Microservice implementations stack:

Today most of the languges provide ms architecture implemenation.

Java frameworks:

1.Microservices with Spring : Spring Cloud Project
2.Eclipse Vert.x
3.Eclipse MicroProfile
etc....

Javascript frameworks: node based framework

1.Moleculer
2.Seneca
3.nonoservices

//////////////////////////////////////////////////////////////////////////////////////////
                                          Moleculer js
				(Progressive Microservice Framework)

What is Moleculer?

Moleculer is a fast, modern and powerful microservices framework for Node.js.

It helps you to build efficient, reliable & scalable services.

Moleculer provides many features for building and managing your microservices.


//////////////////////////////////////////////////////////////////////////////////////

How to start with Molecular Project?


1.setup from begining
2.setup using molecular-cli


Setup:1.setup from begining

mkdir moleculer-simple

2.npm init

3.npm install moleculer


Core Concepts:
..............

1.Service
 A service is a simple JavaScript module containing some part of a complex application. 
 A service represents a biz logic in your application.
eg: orderService,paymentservice,invoiceservice......

2.Service Broker : == Spring Container
 Service Broker is the heart of Moleculer.

 It is responsible for management and communication between services (local and remote). 
 Each node must have an instance of Service Broker.

          "Service Broker is one single Node instance - Node runtime"


		         Service1 -- Service 2 Service N
                                     |
                    		 --------------
				 Service Broker
				     |
                                  Node Runtime

..............................................................................................

Use case 1 : How to create Simple Service, deploy on Service Broker,How to Test?




/**
 * Greeter Service 
 * 
 * ServiceBroker represents Moleculer Runtime.
 */
//Get The ServiceBroker class
const { ServiceBroker } = require('moleculer')

//create ServiceBroker object
const broker = new ServiceBroker();

//service   creation : broker.createService(serviceSchema)
//serviceschema is object which defines properties and methods of service.
broker.createService({
    name: 'hello',
    actions: {
        sayHello(){
            return 'Hello Molecular!'
        }
    }
});


//start process: broker-Runtime
broker.start();

The schema has some main parts: 
	name, version, settings, actions, methods, events.

How to invoke/call Service methods?

There are many ways

1.By using broker.start method
2.By using  REPL cli
3.By using another service => Service to Service calls


When can you call service method/ When can you service?

 Broker(Server/Process) must be ready first,then only, you can access services.

log message in the console, says, services have been deployed and ready to use:

2020-07-22T11:23:35.484Z] INFO  laptop-r2tggfdl-12640/$NODE: Service '$node' started.
[2020-07-22T11:23:35.485Z] INFO  laptop-r2tggfdl-12640/HELLO: Service 'hello' started.
[2020-07-22T11:23:35.487Z] INFO  laptop-r2tggfdl-12640/BROKER: ✔ ServiceBroker with 2 service(s) is started successfully in 8ms.


broker.start() returns Promise, which ensures that , Broker is ready or broker throws
error(not ready.


Calling services methods
.......................

broker.call('serviceName.methodName')



/**
 * Greeter Service 
 * 
 * ServiceBroker represents Moleculer Runtime.
 */
//Get The ServiceBroker class
const { ServiceBroker } = require('moleculer')

//create ServiceBroker object
const broker = new ServiceBroker();

//service   creation : broker.createService(serviceSchema)
//serviceschema is object which defines properties and methods of service.
broker.createService({
    name: 'hello',
    actions: {
        sayHello() {
            return 'Hello Molecular!'
        }
    }
});


//start process: broker-Runtime
broker.start()
    .then(res => {
        //any code , after broker ready
        console.log('broker is ready now , do something, interact with service')
        //call service methods and get result
        broker.call('hello.sayHello')
            .then(message => { console.log(message) })
            .catch(err => console.log('Service error ', err));
    })
    .catch(err => {
        console.log(err);
    })
    .finally(() => {
        console.log('Service broker has done')
    })

broker.start()=>Promise|--->Resoloved---->broker.call()-->Promise--->Result
                     |                                      |
		  Rejected                                  Rejected
			Server/Broker failed                   Service Failed

Async await version:
....................
async function start() {
    try {
        await broker.start();
        let message = await broker.call('hello.sayHello');
        console.log(message);
    }
    catch (err) {
        console.log(err);
    }
    finally {
        console.log('done!!!')
    }
}
start();

********************************************************************************************

Two Services:

/**
 * Greeter Service 
 * 
 * ServiceBroker represents Moleculer Runtime.
 */
//Get The ServiceBroker class
const { ServiceBroker } = require('moleculer')

//create ServiceBroker object
const broker = new ServiceBroker();

//service   creation : broker.createService(serviceSchema)
//serviceschema is object which defines properties and methods of service.
broker.createService({
    name: 'hello',
    actions: {
        sayHello() {
            return 'Hello Molecular!'
        }
    }
});

broker.createService({
    name: 'hai',
    actions: {
        sayHai() {
            return 'Hai Molecular!'
        }
    }
});

async function start() {
    try {
        await broker.start();
        let helloMessage = await broker.call('hello.sayHello');
        let haiMessage = await broker.call('hai.sayHai')
        console.log(` Hello ${helloMessage} Hai ${haiMessage}`);
    }
    catch (err) {
        console.log(err);
    }
    finally {
        console.log('done!!!')
    }
}
start();
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

***********************************************************************************************

Use case service creation separatly, load service and start broker , call service methods?
..........................................................................................

  
services/greeter.service.js
//service definition/service schema

module.exports = {
    name: 'greeter',
    actions: {
        sayGreet() {
            return 'Greeter Service!!!!';
        }
    }
};


broker
services/greeter.service.broker.js
const { ServiceBroker } = require('moleculer')


//create ServiceBroker object
const broker = new ServiceBroker();

//createService not necessary, instead of you can use 
//loadService, load service defition and create Service
broker.loadService('./services/greeter.service.js');


async function start() {
    try {
        await broker.start();
        let greeterMessage = await broker.call('greeter.sayGreet');
        console.log(`${greeterMessage}`);
    }
    catch (err) {
        console.log(err);
    }
    finally {
        console.log('done!!!')
    }
}
start();

*********************************************************************************************

How to start services in REPL Mode:
..................................


npm install moleculer-repl


const { ServiceBroker } = require('moleculer')

//create ServiceBroker object
const broker = new ServiceBroker();

broker.createService({
    name: 'hello',
    actions: {
        sayHello() {
            return 'Hello Molecular!'
        }
    }
});

//broker will be started in repl(Read Evaulate Print Loop)
broker.start();
broker.repl(); 

$ call hello.sayHello

******************************************************************************************

Passing Parameters to Service methods:
.....................................

Note : if you want to get input from outside or from other services.

there is object called "context"

Context Object is used for many purposes:

1.to read parameters from outside or from other services.

ctx object is already created , can injected into service method as arg



const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker();

broker.createService({
    name: 'hello',
    actions: {
        //arg is context object reference
        sayHello(ctx) {
            //context.params={} =inital value is empty
            // console.log(ctx)
            //console.log(ctx.params)
            // return `${ctx.params.message} ${ctx.params.name}`;
            const { message, name } = ctx.params;
            return `${message} ${name}`;
        }
    }
});


async function start() {
    try {
        await broker.start();
        //call method takes two parameters -name of the service,params would be object
        let input = { name: 'Subramanian', message: 'Hello' };
        let helloMessage = await broker.call('hello.sayHello', input);
        console.log(`${helloMessage}`);
    }
    catch (err) {
        console.log(err);
    }
    finally {
        console.log('done!!!')
    }
}
start();
broker.repl();

mol $ call hello.sayHello --name Murugan --message Welcome

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Assignment:
 Create a Service , pass two params which are numbers, return which number is greatest number.


**********************************************************************************************

Service communication:

 How services are communicating each other.


Types of services:

Based on where it is created and how is communicating:
......................................................
1.local service
2.remote service

Based on Use case;

1.Back end Service - Private Services
2.REST end Point -- Public services



1.local service: 

 Services are created and communicated with in single process(Broker)


context :

-can be used to call another service from one service.


const { ServiceBroker } = require('moleculer');

//create Broker 
const broker = new ServiceBroker();

//adder service : which add two number returns result

broker.createService({
    name: 'adder',
    actions: {
        add(ctx) {
            const { a, b } = ctx.params;
            return a + b;
        }
    }
})
broker.createService({
    name: 'substracter',
    actions: {
        substract(ctx) {
            const { a, b } = ctx.params;
            return a - b;
        }
    }
})

broker.createService({
    name: 'calculator',
    actions: {
        async add(ctx) {
            const { a, b } = ctx.params;
            let result = await ctx.call('adder.add', { a: a, b: b });
            console.log(result);
            return result;
        },
        async substract(ctx) {
            const { a, b } = ctx.params;
            let result = await ctx.call('substracter.substract', { a: a, b: b });
            return result;
        }
    }
})

async function start() {
    try {
        await broker.start();
        //call method takes two parameters -name of the service,params would be object
        let input = { a: 10, b: 20 };
        let addRes = await broker.call('calculator.add', input);
        let subRes = await broker.call('calculator.substract', input);
        console.log(` Addition is = ${addRes}`);
        console.log(` Substraction is = ${subRes}`);

    }
    catch (err) {
        console.log(err);
    }
    finally {
        console.log('done!!!')
    }
}
start();

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Remote Services:

->start two brokers independenly.
   -open two cmd 


Service 1
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker();

broker.createService({
    name: 'hellocaller',
    actions: {
        async sayHello(ctx) {
            return await ctx.call('hellocallee.sayHello')
        }
    }
});


//start process: broker-Runtime
async function start() {
    try {
        await broker.start();
        //call method takes two parameters -name of the service,params would be object
        let input = { name: 'Subramanian', message: 'Hello' };
        let helloMessage = await broker.call('hellocaller.sayHello', input);
        console.log(`${helloMessage}`);
    }
    catch (err) {
        console.log(err);
    }
    finally {
        console.log('done!!!')
    }
}
start();
broker.repl();

***********************************************************************************

Service-2
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker();

broker.createService({
    name: 'hellocallee',
    actions: {
        async sayHello(ctx) {
            const { name, message } = ctx.params;
            return `${name} ${message};`
        }
    }
});

broker.start();
broker.repl();
**********************************************************************************************
Micro Service infrastructure components:
.......................................
Networking: 
  we have connect two process via networking infra strcture.

1.Transporter
     who transports data between two brokers.

Service Broker Config:
........................

 By default Service Broker , has default configuration, like service schema,, broker also has
 schema defintion


 let broker = new ServiceBroker() ;;/ default configuration

 let broker =new ServiceBroker({}) // {} Broker Schema configuration


npm install nats --save


Service-1

const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker({
        transporter: "nats://localhost:4222"
});

broker.createService({
    name: 'hellocaller',
    actions: {
        async sayHello(ctx) {
              return await ctx.call('hellocallee.sayHello',ctx.params);
        }
    }
});


//start process: broker-Runtime
async function start() {
    try {
        await broker.start();
        //call method takes two parameters -name of the service,params would be object
        let input = { name: 'Subramanian', message: 'Hello' };
        let helloMessage = await broker.call('hellocaller.sayHello', input);
        console.log(`${helloMessage}`);
    }
    catch (err) {
        console.log(err);
    }
    finally {
        console.log('done!!!')
    }
}
start();
broker.repl();



Service-2

const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker({
    transporter: "nats://localhost:4222"
});

broker.createService({
    name: 'hellocallee',
    actions: {
        async sayHello(ctx) {
            const { name, message } = ctx.params;
            return `${name} ${message};`
        }
    }
});

broker.start();
broker.repl();
**********************************************************************************************
How two services communicate each other, how services are collaborated?


nodeId : the name of the machine, in general node id is name of the computer

const broker = new ServiceBroker({
    transporter: "nats://localhost:4222",
    nodeID : 'IBM Product Server'
});
******************************************************************************************
Registry & Discovery:
....................

1.Service Registry

 It is mini /small database , key-value pair database, in memory database.
 Which has all service,actions,event listeners, nodes information.


Points:
1.Every Broker has in built Service Registry
2.All services local or remote are registered with service registry as soon you create 
  service
3.Molecular has built in registry, which is not using third party registry servers
  like apache zoo keeper,cosule,etcd,eurka....


Registry lookup  Strategy
  How services are going to identity each other

ibm-server-1/REGISTRY: Strategy: RoundRobinStrategy
[2020-07-23T09:11:38.721Z] INFO  ibm-server-1/REGISTRY: Discoverer: LocalDiscoverer


 registry: {
        strategy: "RoundRobin",
        preferLocal: true
    }

Services are registered inside service registry, services communicate via registry only either it is local or remote.


Service Discovery:

Discovery means lookup services.

Molecualr first lookup inside local registry, if found, execution starts else
service lookup happens via transporter.

How to list registry services?

molecular provides administractive service $node

List all nodes which are running in a cluster:

call $node.list
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Load Balancing:

Load balancing means , distributing load to different machines in the cluster.

In distributed computing, one server may not be enough to  handle load.

1.Moleculer has several built-in load balancing strategies.

Built-in strategies
 ->RoundRobin strategy
	This strategy selects a node based on round-robin algorithm.
   Refer:https://en.wikipedia.org/wiki/Round-robin_DNS
 ->Random strategy
	This strategy selects a node randomly.
 ->CPU usage-based strategy
	This strategy selects a node which has the lowest CPU usage. Due to the node list can 	be very long, it gets samples and selects the node with the lowest CPU usage from only 	samples instead of the whole node list.

 ->Latency-based strategy
	This strategy selects a node which has the lowest latency, measured by periodic ping commands. Notice that the strategy only ping one of nodes from a single host.
                                              


Where is load balancer?

 Load balance is built in as part of Registry.

Eg:

1.ProductService with one node
2.InventoryService with 2 nodes
3.Run all nodes and query data from product Service, test node is running.
                                                                                                  
*****************************************************************************************

End to End:
..........

1.moleculer cli
2.moleculer runner
3.api gate way
4.some advanced configurations


Moleculer Runner
   Moleculer Runner is a helper script that helps you running Moleculer projects. With it you don’t need to create a ServiceBroker instance with options. Instead you can create a moleculer.config.js file in the root of repo with broker options. Then simply call the moleculer-runner in NPM script and it will automatically load the configuration file, create the broker and load the services

 npm i -g moleculer-cli

Create Project
$ moleculer init project my-project


moleculer configuration files: Moleculer ServiceBroker configuration file
.........................................................................

Moleculer Runner ----reads moleculer.config.js----creates broker--load services--get Ready...


 Api Gate Way : moleculer-web:
   ->Express Module.... it is written using express.js


Plugins/Modules 
  It is utility /framework/lib - can be attached with moleculer core via mixins

mixins is kind of inhiertance : multi level  inheritance.
 in js multi level inhiertance is achived via a design patten mixins.


eg:
Someservice

module.exports ={
  name:'someservice'
  actions:{}
  ....
}
some service with inheritance
module.exports ={
  name:'someservice'
  mixins:['parent1','parent2']
  actions:{}
  ....
}

Service definitions:

public methods

way 1
actions:{
async sayHello(ctx) {
            const { name, message } = ctx.params;
            return `${name} ${message};`
        }
}

way 2
actions:{
	hello: {
		rest: {
			       method: "GET",
				path: "/hello"
		     },
			async handler() {
		          return "Hello Moleculer";
		        }
	  }
}


//private methods
methods:{
  doSomething(){
     
 }
}



Request WorkFlow:


/api/hello
User----request---------------GateWayServer
                                   -----> /api ------greeterservice---/hello --->handler()




ApiGateWay                           RestEndPoint Layer           BackEndService
  ----/api
     ----Route To Rest Endpoints      








  

